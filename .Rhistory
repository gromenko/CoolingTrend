dl <- eval(inp, data, parent.frame())
dl
names(dl) <- vars
vars
var.summary <- variable.summary(gp$pf, dl, nrow(mf))
var.summary <- mgcv::variable.summary(gp$pf, dl, nrow(mf))
library(mgcv)
mod.gam <- function (formula, family = gaussian(), data = list(), weights = NULL,
subset = NULL, na.action, offset = NULL, method = "GCV.Cp",
optimizer = c("outer", "newton"), control = list(), scale = 0,
select = FALSE, knots = NULL, sp = NULL, min.sp = NULL, H = NULL,
gamma = 1, fit = TRUE, paraPen = NULL, G = NULL, in.out = NULL,
drop.unused.levels = TRUE, ...)
{
control <- do.call("gam.control", control)
if (is.null(G)) {
gp <- interpret.gam(formula)
cl <- match.call()
mf <- match.call(expand.dots = FALSE)
mf$formula <- gp$fake.formula
mf$family <- mf$control <- mf$scale <- mf$knots <- mf$sp <- mf$min.sp <- mf$H <- mf$select <- mf$gamma <- mf$method <- mf$fit <- mf$paraPen <- mf$G <- mf$optimizer <- mf$in.out <- mf$... <- NULL
mf$drop.unused.levels <- drop.unused.levels
mf[[1]] <- as.name("model.frame")
pmf <- mf
mf <- eval(mf, parent.frame())
if (nrow(mf) < 2)
stop("Not enough (non-NA) data to do anything meaningful")
terms <- attr(mf, "terms")
vars <- all.vars(gp$fake.formula[-2])
inp <- parse(text = paste("list(", paste(vars, collapse = ","),
")"))
if (!is.list(data) && !is.data.frame(data))
data <- as.data.frame(data)
dl <- eval(inp, data, parent.frame())
names(dl) <- vars
var.summary <- variable.summary(gp$pf, dl, nrow(mf))
rm(dl)
if (is.list(formula)) {
environment(formula) <- environment(formula[[1]])
pterms <- list()
tlab <- rep("", 0)
for (i in 1:length(formula)) {
pmf$formula <- gp[[i]]$pf
pterms[[i]] <- attr(eval(pmf, parent.frame()),
"terms")
tlabi <- attr(pterms[[i]], "term.labels")
if (i > 1 && length(tlabi) > 0)
tlabi <- paste(tlabi, i - 1, sep = ".")
tlab <- c(tlab, tlabi)
}
attr(pterms, "term.labels") <- tlab
}
else {
pmf$formula <- gp$pf
pmf <- eval(pmf, parent.frame())
pterms <- attr(pmf, "terms")
}
if (is.character(family))
family <- eval(parse(text = family))
if (is.function(family))
family <- family()
if (is.null(family$family))
stop("family not recognized")
if (family$family[1] == "gaussian" && family$link ==
"identity")
am <- TRUE
else am <- FALSE
if (!control$keepData)
rm(data)
drop.intercept <- if (is.null(family$drop.intercept) ||
!family$drop.intercept)
FALSE
else TRUE
if (inherits(family, "general.family") && !is.null(family$presetup))
eval(family$presetup)
gsname <- if (is.list(formula))
"gam.setup.list"
else "gam.setup"
G <- do.call(gsname, list(formula = gp, pterms = pterms,
data = mf, knots = knots, sp = sp, min.sp = min.sp,
H = H, absorb.cons = TRUE, sparse.cons = 0, select = select,
idLinksBases = control$idLinksBases, scale.penalty = control$scalePenalty,
paraPen = paraPen, drop.intercept = drop.intercept))
G$var.summary <- var.summary
G$family <- family
if ((is.list(formula) && (is.null(family$nlp) || family$nlp !=
gp$nlp)) || (!is.list(formula) && !is.null(family$npl) &&
(family$npl > 1)))
stop("incorrect number of linear predictors for family")
if (ncol(G$X) > nrow(G$X))
stop("Model has more coefficients than data")
G$terms <- terms
G$mf <- mf
G$cl <- cl
G$am <- am
if (is.null(G$offset))
G$offset <- rep(0, G$n)
G$min.edf <- G$nsdf
if (G$m)
for (i in 1:G$m) G$min.edf <- G$min.edf + G$smooth[[i]]$null.space.dim
G$formula <- formula
G$pred.formula <- gp$pred.formula
environment(G$formula) <- environment(formula)
}
if (!fit)
return(G)
G$conv.tol <- control$mgcv.tol
G$max.half <- control$mgcv.half
object <- estimate.gam(G, method, optimizer, control, in.out,
scale, gamma, ...)
if (!is.null(G$L)) {
object$full.sp <- as.numeric(exp(G$L %*% log(object$sp) +
G$lsp0))
names(object$full.sp) <- names(G$lsp0)
}
names(object$sp) <- names(G$sp)
object$paraPen <- G$pP
object$formula <- G$formula
if (is.list(object$formula))
attr(object$formula, "lpi") <- attr(G$X, "lpi")
object$var.summary <- G$var.summary
object$cmX <- G$cmX
object$model <- G$mf
object$na.action <- attr(G$mf, "na.action")
object$control <- control
object$terms <- G$terms
object$pred.formula <- G$pred.formula
attr(object$pred.formula, "full") <- reformulate(all.vars(object$terms))
object$pterms <- G$pterms
object$assign <- G$assign
object$contrasts <- G$contrasts
object$xlevels <- G$xlevels
object$offset <- G$offset
object$design <- G$X
if (!is.null(G$Xcentre))
object$Xcentre <- G$Xcentre
if (control$keepData)
object$data <- data
object$df.residual <- nrow(G$X) - sum(object$edf)
object$min.edf <- G$min.edf
if (G$am && !(method %in% c("REML", "ML", "P-ML", "P-REML")))
object$optimizer <- "magic"
else object$optimizer <- optimizer
object$call <- G$cl
class(object) <- c("gam", "glm", "lm")
if (is.null(object$deviance))
object$deviance <- sum(residuals(object, "deviance")^2)
names(object$gcv.ubre) <- method
environment(object$formula) <- environment(object$pred.formula) <- environment(object$terms) <- environment(object$pterms) <- .GlobalEnv
if (!is.null(object$model))
environment(attr(object$model, "terms")) <- .GlobalEnv
if (!is.null(attr(object$pred.formula, "full")))
environment(attr(object$pred.formula, "full")) <- .GlobalEnv
object
}
mod.gam(y~s(x))
rm(list = ls()); gc()
library(mgcv)
x = 1:100
y = sapply(x, function(i) rnorm(1, i, 10))
plot(x,y)
mod.gam <- function (formula, family = gaussian(), data = list(), weights = NULL,
subset = NULL, na.action, offset = NULL, method = "GCV.Cp",
optimizer = c("outer", "newton"), control = list(), scale = 0,
select = FALSE, knots = NULL, sp = NULL, min.sp = NULL, H = NULL,
gamma = 1, fit = TRUE, paraPen = NULL, G = NULL, in.out = NULL,
drop.unused.levels = TRUE, ...)
{
control <- do.call("gam.control", control)
if (is.null(G)) {
gp <- interpret.gam(formula)
cl <- match.call()
mf <- match.call(expand.dots = FALSE)
mf$formula <- gp$fake.formula
mf$family <- mf$control <- mf$scale <- mf$knots <- mf$sp <- mf$min.sp <- mf$H <- mf$select <- mf$gamma <- mf$method <- mf$fit <- mf$paraPen <- mf$G <- mf$optimizer <- mf$in.out <- mf$... <- NULL
mf$drop.unused.levels <- drop.unused.levels
mf[[1]] <- as.name("model.frame")
pmf <- mf
mf <- eval(mf, parent.frame())
if (nrow(mf) < 2)
stop("Not enough (non-NA) data to do anything meaningful")
terms <- attr(mf, "terms")
vars <- all.vars(gp$fake.formula[-2])
inp <- parse(text = paste("list(", paste(vars, collapse = ","),
")"))
if (!is.list(data) && !is.data.frame(data))
data <- as.data.frame(data)
dl <- eval(inp, data, parent.frame())
names(dl) <- vars
var.summary <- variable.summary(gp$pf, dl, nrow(mf))
rm(dl)
if (is.list(formula)) {
environment(formula) <- environment(formula[[1]])
pterms <- list()
tlab <- rep("", 0)
for (i in 1:length(formula)) {
pmf$formula <- gp[[i]]$pf
pterms[[i]] <- attr(eval(pmf, parent.frame()),
"terms")
tlabi <- attr(pterms[[i]], "term.labels")
if (i > 1 && length(tlabi) > 0)
tlabi <- paste(tlabi, i - 1, sep = ".")
tlab <- c(tlab, tlabi)
}
attr(pterms, "term.labels") <- tlab
}
else {
pmf$formula <- gp$pf
pmf <- eval(pmf, parent.frame())
pterms <- attr(pmf, "terms")
}
if (is.character(family))
family <- eval(parse(text = family))
if (is.function(family))
family <- family()
if (is.null(family$family))
stop("family not recognized")
if (family$family[1] == "gaussian" && family$link ==
"identity")
am <- TRUE
else am <- FALSE
if (!control$keepData)
rm(data)
drop.intercept <- if (is.null(family$drop.intercept) ||
!family$drop.intercept)
FALSE
else TRUE
if (inherits(family, "general.family") && !is.null(family$presetup))
eval(family$presetup)
gsname <- if (is.list(formula))
"gam.setup.list"
else "gam.setup"
G <- do.call(gsname, list(formula = gp, pterms = pterms,
data = mf, knots = knots, sp = sp, min.sp = min.sp,
H = H, absorb.cons = TRUE, sparse.cons = 0, select = select,
idLinksBases = control$idLinksBases, scale.penalty = control$scalePenalty,
paraPen = paraPen, drop.intercept = drop.intercept))
G$var.summary <- var.summary
G$family <- family
if ((is.list(formula) && (is.null(family$nlp) || family$nlp !=
gp$nlp)) || (!is.list(formula) && !is.null(family$npl) &&
(family$npl > 1)))
stop("incorrect number of linear predictors for family")
if (ncol(G$X) > nrow(G$X))
stop("Model has more coefficients than data")
G$terms <- terms
G$mf <- mf
G$cl <- cl
G$am <- am
if (is.null(G$offset))
G$offset <- rep(0, G$n)
G$min.edf <- G$nsdf
if (G$m)
for (i in 1:G$m) G$min.edf <- G$min.edf + G$smooth[[i]]$null.space.dim
G$formula <- formula
G$pred.formula <- gp$pred.formula
environment(G$formula) <- environment(formula)
}
if (!fit)
return(G)
G$conv.tol <- control$mgcv.tol
G$max.half <- control$mgcv.half
object <- estimate.gam(G, method, optimizer, control, in.out,
scale, gamma, ...)
if (!is.null(G$L)) {
object$full.sp <- as.numeric(exp(G$L %*% log(object$sp) +
G$lsp0))
names(object$full.sp) <- names(G$lsp0)
}
names(object$sp) <- names(G$sp)
object$paraPen <- G$pP
object$formula <- G$formula
if (is.list(object$formula))
attr(object$formula, "lpi") <- attr(G$X, "lpi")
object$var.summary <- G$var.summary
object$cmX <- G$cmX
object$model <- G$mf
object$na.action <- attr(G$mf, "na.action")
object$control <- control
object$terms <- G$terms
object$pred.formula <- G$pred.formula
attr(object$pred.formula, "full") <- reformulate(all.vars(object$terms))
object$pterms <- G$pterms
object$assign <- G$assign
object$contrasts <- G$contrasts
object$xlevels <- G$xlevels
object$offset <- G$offset
object$design <- G$X
if (!is.null(G$Xcentre))
object$Xcentre <- G$Xcentre
if (control$keepData)
object$data <- data
object$df.residual <- nrow(G$X) - sum(object$edf)
object$min.edf <- G$min.edf
if (G$am && !(method %in% c("REML", "ML", "P-ML", "P-REML")))
object$optimizer <- "magic"
else object$optimizer <- optimizer
object$call <- G$cl
class(object) <- c("gam", "glm", "lm")
if (is.null(object$deviance))
object$deviance <- sum(residuals(object, "deviance")^2)
names(object$gcv.ubre) <- method
environment(object$formula) <- environment(object$pred.formula) <- environment(object$terms) <- environment(object$pterms) <- .GlobalEnv
if (!is.null(object$model))
environment(attr(object$model, "terms")) <- .GlobalEnv
if (!is.null(attr(object$pred.formula, "full")))
environment(attr(object$pred.formula, "full")) <- .GlobalEnv
object
}
mod.gam(y~s(x))
gam(y~s(x))
mgcv:::mod.gam(y~s(x))
environment(mod.gam) <- environment(gam)
mod.gam(y~s(x))
gam(y~s(x))
fit <- mod.gam(y~s(x))
summary(fit)
fit$design
rm(list = ls()); gc()
setwd('~/Work/MissAgain/data/')
#library(mgcv)
#library(parallel)
source('functions2.R')
stations <- read.table('data_noon/IonoStations.txt', header = T, sep = '|', stringsAsFactors = F)
data <- read.csv('data_noon/DATA_PROC.csv', header = T, stringsAsFactors = F)
#stations for research
stations<-stations[stations$LAT <= 60 & stations$LAT >= 30,]
nrow(stations)
data = data[data$CODE %in% stations$CODE,]
stations = stations[stations$CODE %in% data$CODE,]
length(unique(data$CODE))
length(stations$CODE)
data$M = sin(data$I/180 * pi)*cos(data$I/180 * pi)
data <- data[!(data$YEAR %in% c(2014, 2015)),]
data$INT <- 1
variables <- c("TREND", "F107", "H_NT", "INT")
fm <- paste0("FREQ~0+",paste0(variables, collapse = "+"))
xr <- unique(data$YEAR)
hx <- head(xr,1)
tx <- tail(xr,1)
result <- c()
centers <- xr[3:(length(xr)-2)]
for(cn in centers){
#cat(cn, ':')
ml <- min(abs(cn - hx), abs(cn - tx))
for(i in 2:ml){
ys <- (cn - i) : (cn + i)
tmp <- data[data$YEAR %in% ys ,]
fit <- glm(as.formula(fm), data = tmp)
result <- rbind(result, c(cn, i, coef(summary(fit))[1,c(1,4)]))
}
cat(cn, '\n')
}
#st model
dir <- 'logs/logRobust/'
fnames <- list.files(dir)
xs <- gsub(pattern = 'log.txt', '', fnames)
year   <- as.numeric(substr(xs, 2, 5))
length <- as.numeric(substr(xs, 7, 10))
resultST <- c()
for(i in 1:length(fnames)){
tmp <- readLines(paste0(dir, fnames[i]))
if(length(grep('Iteration:', tmp)) > 15){
trEst <- na.omit(as.numeric(sapply(strsplit(gsub('E:','',tmp[grep('Iteration:', tmp) + 1]), '[,]'), function(x) x[1])))
trSde <- na.omit(as.numeric(sapply(strsplit(gsub('V:','',tmp[grep('Iteration:', tmp) + 2]), '[,]'), function(x) x[1])))
mn <- mean(trEst[10:length(trEst)])
md <- median(trEst[10:length(trEst)])
mnSe <- mean(trSde[10:length(trSde)])
mdSe <- median(trSde[10:length(trSde)])
ind <- 0
ind <- ifelse(length(which(trEst > 0)), 1, 0)
if(abs(mn - md) < tail(trSde,1)){
e <- mn * 365 * 1000
s <- mnSe * 365 * 1000
p <- 2 * pnorm(abs(e / s),lower.tail = F)
resultST <- rbind(resultST, c(year[i], length[i], e, p))
}
}
}
xlim <- range(result[,1])
ylim <- range(result[,2])
atv = seq(1960, 2010, by = 10)
ath = seq(5, 25, by = 5)
resps <- result[result[,3] >  0 & result[,4] <= 0.05,]
respu <- result[result[,3] >  0 & result[,4] >  0.05,]
resns <- result[result[,3] <= 0 & result[,4] <= 0.05,]
resnu <- result[result[,3] <= 0 & result[,4] >  0.05,]
respsST <- resultST[resultST[,3] >  0 & resultST[,4] <= 0.05,]
respuST <- resultST[resultST[,3] >  0 & resultST[,4] >  0.05,]
resnsST <- resultST[resultST[,3] <= 0 & resultST[,4] <= 0.05,]
resnuST <- resultST[resultST[,3] <= 0 & resultST[,4] >  0.05,]
cex = 0.8
postscript('resampling.eps', width = 9, height = 3)
par(mar = c(2,2,1,1))
layout(matrix(nc = 2, nr = 1, 1:2))
plot(1,1, xlim = xlim, ylim = ylim, type = "n", xlab = NA, ylab = NA)
abline(v = atv, lty = 'dotted')
abline(h = ath, lty = 'dotted')
points(resps[,1], resps[,2], pch = 3, col = "red", cex = cex)
points(respu[,1], respu[,2], pch = 5, col = "red", cex = cex)
points(resns[,1], resns[,2], pch = 19, col = "blue", cex = cex)
points(resnu[,1], resnu[,2], pch = 1, col = "blue", cex = cex)
plot(1,1, xlim = xlim, ylim = ylim, type = "n", xlab = NA, ylab = NA)
abline(v = atv, lty = 'dotted')
abline(h = ath, lty = 'dotted')
points(respsST[,1], respsST[,2], pch = 3, col = "red", cex = cex)
points(respuST[,1], respuST[,2], pch = 5, col = "red", cex = cex)
points(resnsST[,1], resnsST[,2], pch = 19, col = "blue", cex = cex)
points(resnuST[,1], resnuST[,2], pch = 1, col = "blue", cex = cex)
dev.off()
rm(list = ls()); gc()
setwd('~/Work/MissAgain/data/')
#library(mgcv)
#library(parallel)
source('functions2.R')
stations <- read.table('data_noon/IonoStations.txt', header = T, sep = '|', stringsAsFactors = F)
data <- read.csv('data_noon/DATA_PROC.csv', header = T, stringsAsFactors = F)
#stations for research
stations<-stations[stations$LAT <= 60 & stations$LAT >= 30,]
nrow(stations)
data = data[data$CODE %in% stations$CODE,]
stations = stations[stations$CODE %in% data$CODE,]
length(unique(data$CODE))
length(stations$CODE)
data$M = sin(data$I/180 * pi)*cos(data$I/180 * pi)
data <- data[!(data$YEAR %in% c(2014, 2015)),]
data$INT <- 1
variables <- c("TREND", "F107", "H_NT", "INT")
fm <- paste0("FREQ~0+",paste0(variables, collapse = "+"))
xr <- unique(data$YEAR)
hx <- head(xr,1)
tx <- tail(xr,1)
result <- c()
centers <- xr[3:(length(xr)-2)]
for(cn in centers){
#cat(cn, ':')
ml <- min(abs(cn - hx), abs(cn - tx))
for(i in 2:ml){
ys <- (cn - i) : (cn + i)
tmp <- data[data$YEAR %in% ys ,]
fit <- glm(as.formula(fm), data = tmp)
result <- rbind(result, c(cn, i, coef(summary(fit))[1,c(1,4)]))
}
cat(cn, '\n')
}
#st model
dir <- 'logs/logRobust/'
fnames <- list.files(dir)
xs <- gsub(pattern = 'log.txt', '', fnames)
year   <- as.numeric(substr(xs, 2, 5))
length <- as.numeric(substr(xs, 7, 10))
resultST <- c()
for(i in 1:length(fnames)){
tmp <- readLines(paste0(dir, fnames[i]))
if(length(grep('Iteration:', tmp)) > 15){
trEst <- na.omit(as.numeric(sapply(strsplit(gsub('E:','',tmp[grep('Iteration:', tmp) + 1]), '[,]'), function(x) x[1])))
trSde <- na.omit(as.numeric(sapply(strsplit(gsub('V:','',tmp[grep('Iteration:', tmp) + 2]), '[,]'), function(x) x[1])))
mn <- mean(trEst[10:length(trEst)])
md <- median(trEst[10:length(trEst)])
mnSe <- mean(trSde[10:length(trSde)])
mdSe <- median(trSde[10:length(trSde)])
ind <- 0
ind <- ifelse(length(which(trEst > 0)), 1, 0)
if(abs(mn - md) < tail(trSde,1)){
e <- mn * 365 * 1000
s <- mnSe * 365 * 1000
p <- 2 * pnorm(abs(e / s),lower.tail = F)
resultST <- rbind(resultST, c(year[i], length[i], e, p))
}
}
}
xlim <- range(result[,1])
ylim <- range(result[,2])
atv = seq(1960, 2010, by = 10)
ath = seq(5, 25, by = 5)
resps <- result[result[,3] >  0 & result[,4] <= 0.05,]
respu <- result[result[,3] >  0 & result[,4] >  0.05,]
resns <- result[result[,3] <= 0 & result[,4] <= 0.05,]
resnu <- result[result[,3] <= 0 & result[,4] >  0.05,]
respsST <- resultST[resultST[,3] >  0 & resultST[,4] <= 0.05,]
respuST <- resultST[resultST[,3] >  0 & resultST[,4] >  0.05,]
resnsST <- resultST[resultST[,3] <= 0 & resultST[,4] <= 0.05,]
resnuST <- resultST[resultST[,3] <= 0 & resultST[,4] >  0.05,]
cex = 0.8
postscript('resampling.eps', width = 9, height = 3)
par(mar = c(2,2,1,1))
layout(matrix(nc = 2, nr = 1, 1:2))
plot(1,1, xlim = xlim, ylim = ylim, type = "n", xlab = NA, ylab = NA)
abline(v = atv, lty = 'dotted')
abline(h = ath, lty = 'dotted')
points(resps[,1], resps[,2], pch = 3, col = "red", cex = cex)
points(respu[,1], respu[,2], pch = 5, col = "red", cex = cex)
points(resns[,1], resns[,2], pch = 19, col = "blue", cex = cex)
points(resnu[,1], resnu[,2], pch = 1, col = "blue", cex = cex)
plot(1,1, xlim = xlim, ylim = ylim, type = "n", xlab = NA, ylab = NA)
abline(v = atv, lty = 'dotted')
abline(h = ath, lty = 'dotted')
points(respsST[,1], respsST[,2], pch = 3, col = "red", cex = cex)
points(respuST[,1], respuST[,2], pch = 5, col = "red", cex = cex)
points(resnsST[,1], resnsST[,2], pch = 19, col = "blue", cex = cex)
points(resnuST[,1], resnuST[,2], pch = 1, col = "blue", cex = cex)
dev.off()
rm(list = ls()); gc()
this.dir <- dirname(parent.frame(2)$ofile)
parent.frame(2)
parent.frame(2)$ofile
parent.frame(2)$ofile
dirname(sys.frame(1)$ofile)
dirname(sys.frame(1)$ofile)
rm(list = ls()); gc()
setwd('~/Work/CoolingTrend')
source('functions2.R')
